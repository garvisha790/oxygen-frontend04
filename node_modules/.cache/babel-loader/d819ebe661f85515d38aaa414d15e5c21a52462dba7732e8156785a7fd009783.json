{"ast":null,"code":"import axios from 'axios';\n\n// Use the correct base URL without the \"telemetry\" path\nconst BASE_URL = process.env.REACT_APP_API_BASE_URL || \"http://localhost:5000/api\";\n\n// Configure axios defaults for better error handling\naxios.defaults.timeout = 10000; // 10 second timeout\naxios.defaults.retry = 2;\naxios.defaults.retryDelay = 1000;\n\n// Create axios instance with retry logic\nconst axiosInstance = axios.create();\naxiosInstance.interceptors.response.use(null, async error => {\n  const {\n    config\n  } = error;\n  if (!config || !config.retry) {\n    return Promise.reject(error);\n  }\n  config.retryCount = config.retryCount || 0;\n  if (config.retryCount >= config.retry) {\n    return Promise.reject(error);\n  }\n  config.retryCount += 1;\n  const delay = config.retryDelay || 1000;\n  console.log(`Retrying request (${config.retryCount}/${config.retry})...`);\n  return new Promise(resolve => setTimeout(() => resolve(axiosInstance(config)), delay));\n});\n\n// Cache management for historical telemetry data\nlet historicalCache = {};\nlet lastHistoricalFetch = {};\n\n/**\n * Fetch historical telemetry data (last 20 entries) for a given deviceId\n * @param {string} deviceId - The ID of the device to fetch data for\n * @returns {Promise<Array>} - Array of telemetry data points\n */\nexport const getTelemetryData = async deviceId => {\n  try {\n    // Implement cache control to prevent excessive API calls\n    const now = Date.now();\n    const cacheTime = 30000; // 30 seconds cache for historical data\n\n    if (!historicalCache[deviceId] || !lastHistoricalFetch[deviceId] || now - lastHistoricalFetch[deviceId] > cacheTime) {\n      console.log('üìä Fetching fresh historical telemetry data...');\n      try {\n        const response = await axiosInstance.get(`${BASE_URL}/telemetry/${deviceId}`);\n        if (response.data && response.data.length > 0) {\n          historicalCache[deviceId] = response.data || [];\n          lastHistoricalFetch[deviceId] = now;\n        } else if (!historicalCache[deviceId]) {\n          // If no data returned and no cache exists, create empty array\n          historicalCache[deviceId] = [];\n        }\n        // If we got an empty result but have cached data, keep using the cache\n      } catch (error) {\n        console.error(\"‚ùå Error fetching historical telemetry data:\", error);\n        // Still return cached data if available\n        if (!historicalCache[deviceId]) {\n          historicalCache[deviceId] = [];\n        }\n      }\n    } else {\n      console.log('üìä Using cached historical telemetry data...');\n    }\n    return historicalCache[deviceId];\n  } catch (error) {\n    console.error(\"‚ùå Error in getTelemetryData:\", error);\n    return historicalCache[deviceId] || [];\n  }\n};\n\n// Cache management for real-time telemetry data\nlet realtimeCache = {};\nlet lastRealtimeFetch = {};\n\n/**\n * Fetch real-time telemetry data (last 10 minutes) for a given deviceId\n * @param {string} deviceId - The ID of the device to fetch data for\n * @returns {Promise<Array>} - Array of telemetry data points\n */\nexport const getRealtimeTelemetryData = async deviceId => {\n  try {\n    // Implement cache control with shorter lifetime for real-time data\n    const now = Date.now();\n    const cacheTime = 5000; // 5 seconds cache\n\n    if (!realtimeCache[deviceId] || !lastRealtimeFetch[deviceId] || now - lastRealtimeFetch[deviceId] > cacheTime) {\n      console.log('‚ö° Fetching fresh real-time telemetry data...');\n      try {\n        const response = await axiosInstance.get(`${BASE_URL}/telemetry/realtime/${deviceId}`);\n        if (response.data && response.data.length > 0) {\n          realtimeCache[deviceId] = response.data || [];\n          lastRealtimeFetch[deviceId] = now;\n        } else {\n          // If realtime API returns no data, try to use historical data\n          console.log('No realtime data found, trying historical data...');\n          const historicalData = await getTelemetryData(deviceId);\n          if (historicalData && historicalData.length > 0) {\n            // Use last 20 entries from historical data\n            realtimeCache[deviceId] = historicalData.slice(0, 20);\n            lastRealtimeFetch[deviceId] = now;\n          } else if (!realtimeCache[deviceId]) {\n            realtimeCache[deviceId] = [];\n          }\n        }\n      } catch (error) {\n        console.error(\"‚ùå Error fetching real-time telemetry data:\", error);\n        // Try to use historical data if available\n        try {\n          const historicalData = await getTelemetryData(deviceId);\n          if (historicalData && historicalData.length > 0) {\n            realtimeCache[deviceId] = historicalData.slice(0, 20);\n            lastRealtimeFetch[deviceId] = now;\n          } else if (!realtimeCache[deviceId]) {\n            realtimeCache[deviceId] = [];\n          }\n        } catch (innerError) {\n          console.error(\"‚ùå Also failed to get historical data:\", innerError);\n          if (!realtimeCache[deviceId]) {\n            realtimeCache[deviceId] = [];\n          }\n        }\n      }\n    } else {\n      console.log('‚ö° Using cached real-time telemetry data...');\n    }\n    return realtimeCache[deviceId];\n  } catch (error) {\n    console.error(\"‚ùå Error in getRealtimeTelemetryData:\", error);\n    return realtimeCache[deviceId] || [];\n  }\n};\n\n// Cache management for latest telemetry entry\nlet latestEntryCache = {};\nlet lastLatestFetch = {};\n\n/**\n * Fetch the latest telemetry entry for a given deviceId (for dashboard indicators)\n * @param {string} deviceId - The ID of the device to fetch data for\n * @returns {Promise<Object>} - Latest telemetry entry\n */\nexport const getLatestTelemetryEntry = async deviceId => {\n  try {\n    // Implement cache control with very short lifetime for latest data\n    const now = Date.now();\n    const cacheTime = 5000; // 5 seconds cache\n\n    if (!latestEntryCache[deviceId] || !lastLatestFetch[deviceId] || now - lastLatestFetch[deviceId] > cacheTime) {\n      console.log('üîÑ Fetching fresh latest telemetry entry...');\n      try {\n        const response = await axiosInstance.get(`${BASE_URL}/telemetry/latest/${deviceId}`);\n        if (response.data) {\n          latestEntryCache[deviceId] = response.data;\n          lastLatestFetch[deviceId] = now;\n        } else {\n          // If no latest data, try to use the first entry from historical data\n          console.log('No latest entry found, trying historical data...');\n          const historicalData = await getTelemetryData(deviceId);\n          if (historicalData && historicalData.length > 0) {\n            // Sort by timestamp, newest first\n            const sortedData = [...historicalData].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n            latestEntryCache[deviceId] = sortedData[0];\n            lastLatestFetch[deviceId] = now;\n          } else if (!latestEntryCache[deviceId]) {\n            latestEntryCache[deviceId] = null;\n          }\n        }\n      } catch (error) {\n        console.error(\"‚ùå Error fetching latest telemetry entry:\", error);\n        // Try to use the first entry from historical data\n        try {\n          const historicalData = await getTelemetryData(deviceId);\n          if (historicalData && historicalData.length > 0) {\n            // Sort by timestamp, newest first\n            const sortedData = [...historicalData].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n            latestEntryCache[deviceId] = sortedData[0];\n            lastLatestFetch[deviceId] = now;\n          } else if (!latestEntryCache[deviceId]) {\n            latestEntryCache[deviceId] = null;\n          }\n        } catch (innerError) {\n          console.error(\"‚ùå Also failed to get historical data for latest entry:\", innerError);\n          if (!latestEntryCache[deviceId]) {\n            latestEntryCache[deviceId] = null;\n          }\n        }\n      }\n    } else {\n      console.log('üîÑ Using cached latest telemetry entry...');\n    }\n    return latestEntryCache[deviceId];\n  } catch (error) {\n    console.error(\"‚ùå Error in getLatestTelemetryEntry:\", error);\n    return latestEntryCache[deviceId] || null;\n  }\n};\n\n/**\n * Clear all cache for a specific deviceId when switching devices\n * @param {string} deviceId - The ID of the device to clear cache for\n */\nexport const clearDeviceCache = deviceId => {\n  if (deviceId) {\n    // Clear specific device cache\n    delete historicalCache[deviceId];\n    delete lastHistoricalFetch[deviceId];\n    delete realtimeCache[deviceId];\n    delete lastRealtimeFetch[deviceId];\n    delete latestEntryCache[deviceId];\n    delete lastLatestFetch[deviceId];\n    console.log(`üßπ Cleared cache for device ${deviceId}`);\n  } else {\n    // Clear all cache\n    historicalCache = {};\n    lastHistoricalFetch = {};\n    realtimeCache = {};\n    lastRealtimeFetch = {};\n    latestEntryCache = {};\n    lastLatestFetch = {};\n    console.log('üßπ Cleared all device cache');\n  }\n};","map":{"version":3,"names":["axios","BASE_URL","process","env","REACT_APP_API_BASE_URL","defaults","timeout","retry","retryDelay","axiosInstance","create","interceptors","response","use","error","config","Promise","reject","retryCount","delay","console","log","resolve","setTimeout","historicalCache","lastHistoricalFetch","getTelemetryData","deviceId","now","Date","cacheTime","get","data","length","realtimeCache","lastRealtimeFetch","getRealtimeTelemetryData","historicalData","slice","innerError","latestEntryCache","lastLatestFetch","getLatestTelemetryEntry","sortedData","sort","a","b","timestamp","clearDeviceCache"],"sources":["C:/Users/Garvisha/Desktop/Front/oxygen-frontend/src/services/telemetryService.js"],"sourcesContent":["import axios from 'axios';\n\n// Use the correct base URL without the \"telemetry\" path\nconst BASE_URL = process.env.REACT_APP_API_BASE_URL || \"http://localhost:5000/api\";\n\n// Configure axios defaults for better error handling\naxios.defaults.timeout = 10000; // 10 second timeout\naxios.defaults.retry = 2;\naxios.defaults.retryDelay = 1000;\n\n// Create axios instance with retry logic\nconst axiosInstance = axios.create();\naxiosInstance.interceptors.response.use(null, async (error) => {\n  const { config } = error;\n  if (!config || !config.retry) {\n    return Promise.reject(error);\n  }\n  \n  config.retryCount = config.retryCount || 0;\n  if (config.retryCount >= config.retry) {\n    return Promise.reject(error);\n  }\n  \n  config.retryCount += 1;\n  const delay = config.retryDelay || 1000;\n  console.log(`Retrying request (${config.retryCount}/${config.retry})...`);\n  \n  return new Promise(resolve => setTimeout(() => resolve(axiosInstance(config)), delay));\n});\n\n// Cache management for historical telemetry data\nlet historicalCache = {};\nlet lastHistoricalFetch = {};\n\n/**\n * Fetch historical telemetry data (last 20 entries) for a given deviceId\n * @param {string} deviceId - The ID of the device to fetch data for\n * @returns {Promise<Array>} - Array of telemetry data points\n */\nexport const getTelemetryData = async (deviceId) => {\n  try {\n    // Implement cache control to prevent excessive API calls\n    const now = Date.now();\n    const cacheTime = 30000; // 30 seconds cache for historical data\n    \n    if (!historicalCache[deviceId] || !lastHistoricalFetch[deviceId] || \n        (now - lastHistoricalFetch[deviceId] > cacheTime)) {\n      console.log('üìä Fetching fresh historical telemetry data...');\n      try {\n        const response = await axiosInstance.get(`${BASE_URL}/telemetry/${deviceId}`);\n        if (response.data && response.data.length > 0) {\n          historicalCache[deviceId] = response.data || [];\n          lastHistoricalFetch[deviceId] = now;\n        } else if (!historicalCache[deviceId]) {\n          // If no data returned and no cache exists, create empty array\n          historicalCache[deviceId] = [];\n        }\n        // If we got an empty result but have cached data, keep using the cache\n      } catch (error) {\n        console.error(\"‚ùå Error fetching historical telemetry data:\", error);\n        // Still return cached data if available\n        if (!historicalCache[deviceId]) {\n          historicalCache[deviceId] = [];\n        }\n      }\n    } else {\n      console.log('üìä Using cached historical telemetry data...');\n    }\n    \n    return historicalCache[deviceId];\n  } catch (error) {\n    console.error(\"‚ùå Error in getTelemetryData:\", error);\n    return historicalCache[deviceId] || [];\n  }\n};\n\n// Cache management for real-time telemetry data\nlet realtimeCache = {};\nlet lastRealtimeFetch = {};\n\n/**\n * Fetch real-time telemetry data (last 10 minutes) for a given deviceId\n * @param {string} deviceId - The ID of the device to fetch data for\n * @returns {Promise<Array>} - Array of telemetry data points\n */\nexport const getRealtimeTelemetryData = async (deviceId) => {\n  try {\n    // Implement cache control with shorter lifetime for real-time data\n    const now = Date.now();\n    const cacheTime = 5000; // 5 seconds cache\n    \n    if (!realtimeCache[deviceId] || !lastRealtimeFetch[deviceId] || \n        (now - lastRealtimeFetch[deviceId] > cacheTime)) {\n      console.log('‚ö° Fetching fresh real-time telemetry data...');\n      try {\n        const response = await axiosInstance.get(`${BASE_URL}/telemetry/realtime/${deviceId}`);\n        if (response.data && response.data.length > 0) {\n          realtimeCache[deviceId] = response.data || [];\n          lastRealtimeFetch[deviceId] = now;\n        } else {\n          // If realtime API returns no data, try to use historical data\n          console.log('No realtime data found, trying historical data...');\n          const historicalData = await getTelemetryData(deviceId);\n          if (historicalData && historicalData.length > 0) {\n            // Use last 20 entries from historical data\n            realtimeCache[deviceId] = historicalData.slice(0, 20);\n            lastRealtimeFetch[deviceId] = now;\n          } else if (!realtimeCache[deviceId]) {\n            realtimeCache[deviceId] = [];\n          }\n        }\n      } catch (error) {\n        console.error(\"‚ùå Error fetching real-time telemetry data:\", error);\n        // Try to use historical data if available\n        try {\n          const historicalData = await getTelemetryData(deviceId);\n          if (historicalData && historicalData.length > 0) {\n            realtimeCache[deviceId] = historicalData.slice(0, 20);\n            lastRealtimeFetch[deviceId] = now;\n          } else if (!realtimeCache[deviceId]) {\n            realtimeCache[deviceId] = [];\n          }\n        } catch (innerError) {\n          console.error(\"‚ùå Also failed to get historical data:\", innerError);\n          if (!realtimeCache[deviceId]) {\n            realtimeCache[deviceId] = [];\n          }\n        }\n      }\n    } else {\n      console.log('‚ö° Using cached real-time telemetry data...');\n    }\n    \n    return realtimeCache[deviceId];\n  } catch (error) {\n    console.error(\"‚ùå Error in getRealtimeTelemetryData:\", error);\n    return realtimeCache[deviceId] || [];\n  }\n};\n\n// Cache management for latest telemetry entry\nlet latestEntryCache = {};\nlet lastLatestFetch = {};\n\n/**\n * Fetch the latest telemetry entry for a given deviceId (for dashboard indicators)\n * @param {string} deviceId - The ID of the device to fetch data for\n * @returns {Promise<Object>} - Latest telemetry entry\n */\nexport const getLatestTelemetryEntry = async (deviceId) => {\n  try {\n    // Implement cache control with very short lifetime for latest data\n    const now = Date.now();\n    const cacheTime = 5000; // 5 seconds cache\n    \n    if (!latestEntryCache[deviceId] || !lastLatestFetch[deviceId] || \n        (now - lastLatestFetch[deviceId] > cacheTime)) {\n      console.log('üîÑ Fetching fresh latest telemetry entry...');\n      try {\n        const response = await axiosInstance.get(`${BASE_URL}/telemetry/latest/${deviceId}`);\n        if (response.data) {\n          latestEntryCache[deviceId] = response.data;\n          lastLatestFetch[deviceId] = now;\n        } else {\n          // If no latest data, try to use the first entry from historical data\n          console.log('No latest entry found, trying historical data...');\n          const historicalData = await getTelemetryData(deviceId);\n          if (historicalData && historicalData.length > 0) {\n            // Sort by timestamp, newest first\n            const sortedData = [...historicalData].sort((a, b) => \n              new Date(b.timestamp) - new Date(a.timestamp)\n            );\n            latestEntryCache[deviceId] = sortedData[0];\n            lastLatestFetch[deviceId] = now;\n          } else if (!latestEntryCache[deviceId]) {\n            latestEntryCache[deviceId] = null;\n          }\n        }\n      } catch (error) {\n        console.error(\"‚ùå Error fetching latest telemetry entry:\", error);\n        // Try to use the first entry from historical data\n        try {\n          const historicalData = await getTelemetryData(deviceId);\n          if (historicalData && historicalData.length > 0) {\n            // Sort by timestamp, newest first\n            const sortedData = [...historicalData].sort((a, b) => \n              new Date(b.timestamp) - new Date(a.timestamp)\n            );\n            latestEntryCache[deviceId] = sortedData[0];\n            lastLatestFetch[deviceId] = now;\n          } else if (!latestEntryCache[deviceId]) {\n            latestEntryCache[deviceId] = null;\n          }\n        } catch (innerError) {\n          console.error(\"‚ùå Also failed to get historical data for latest entry:\", innerError);\n          if (!latestEntryCache[deviceId]) {\n            latestEntryCache[deviceId] = null;\n          }\n        }\n      }\n    } else {\n      console.log('üîÑ Using cached latest telemetry entry...');\n    }\n    \n    return latestEntryCache[deviceId];\n  } catch (error) {\n    console.error(\"‚ùå Error in getLatestTelemetryEntry:\", error);\n    return latestEntryCache[deviceId] || null;\n  }\n};\n\n/**\n * Clear all cache for a specific deviceId when switching devices\n * @param {string} deviceId - The ID of the device to clear cache for\n */\nexport const clearDeviceCache = (deviceId) => {\n  if (deviceId) {\n    // Clear specific device cache\n    delete historicalCache[deviceId];\n    delete lastHistoricalFetch[deviceId];\n    delete realtimeCache[deviceId];\n    delete lastRealtimeFetch[deviceId];\n    delete latestEntryCache[deviceId];\n    delete lastLatestFetch[deviceId];\n    console.log(`üßπ Cleared cache for device ${deviceId}`);\n  } else {\n    // Clear all cache\n    historicalCache = {};\n    lastHistoricalFetch = {};\n    realtimeCache = {};\n    lastRealtimeFetch = {};\n    latestEntryCache = {};\n    lastLatestFetch = {};\n    console.log('üßπ Cleared all device cache');\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}