{"ast":null,"code":"import axios from 'axios';\n\n// Use the correct base URL without the \"telemetry\" path\nconst BASE_URL = process.env.REACT_APP_API_BASE_URL || \"http://localhost:5000/api\";\n\n// Configure axios defaults for better error handling\naxios.defaults.timeout = 10000; // 10 second timeout\naxios.defaults.retry = 2;\naxios.defaults.retryDelay = 1000;\n\n// Create axios instance with retry logic\nconst axiosInstance = axios.create();\naxiosInstance.interceptors.response.use(null, async error => {\n  const {\n    config\n  } = error;\n  if (!config || !config.retry) {\n    return Promise.reject(error);\n  }\n  config.retryCount = config.retryCount || 0;\n  if (config.retryCount >= config.retry) {\n    return Promise.reject(error);\n  }\n  config.retryCount += 1;\n  const delay = config.retryDelay || 1000;\n  console.log(`Retrying request (${config.retryCount}/${config.retry})...`);\n  return new Promise(resolve => setTimeout(() => resolve(axiosInstance(config)), delay));\n});\n\n// Cache management for historical telemetry data\nlet historicalCache = {};\nlet lastHistoricalFetch = {};\n\n/**\r\n * Fetch historical telemetry data (last 20 entries) for a given deviceId\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Array>} - Array of telemetry data points\r\n */\nexport const getTelemetryData = async deviceId => {\n  try {\n    // Implement cache control to prevent excessive API calls\n    const now = Date.now();\n    const cacheTime = 10000; // 10 seconds cache for historical data\n\n    if (!historicalCache[deviceId] || !lastHistoricalFetch[deviceId] || now - lastHistoricalFetch[deviceId] > cacheTime) {\n      console.log('üìä Fetching fresh historical telemetry data...');\n      const response = await axiosInstance.get(`${BASE_URL}/telemetry/${deviceId}`);\n      historicalCache[deviceId] = response.data || [];\n      lastHistoricalFetch[deviceId] = now;\n    } else {\n      console.log('üìä Using cached historical telemetry data...');\n    }\n    return historicalCache[deviceId];\n  } catch (error) {\n    console.error(\"‚ùå Error fetching historical telemetry data:\", error);\n    return [];\n  }\n};\n\n// Cache management for real-time telemetry data\nlet realtimeCache = {};\nlet lastRealtimeFetch = {};\n\n/**\r\n * Fetch real-time telemetry data (last 10 minutes) for a given deviceId\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Array>} - Array of telemetry data points\r\n */\nexport const getRealtimeTelemetryData = async deviceId => {\n  try {\n    // Implement cache control with shorter lifetime for real-time data\n    const now = Date.now();\n    const cacheTime = 3000; // 3 seconds cache\n\n    if (!realtimeCache[deviceId] || !lastRealtimeFetch[deviceId] || now - lastRealtimeFetch[deviceId] > cacheTime) {\n      console.log('‚ö° Fetching fresh real-time telemetry data...');\n      const response = await axiosInstance.get(`${BASE_URL}/telemetry/realtime/${deviceId}`);\n      realtimeCache[deviceId] = response.data || [];\n      lastRealtimeFetch[deviceId] = now;\n    } else {\n      console.log('‚ö° Using cached real-time telemetry data...');\n    }\n    return realtimeCache[deviceId];\n  } catch (error) {\n    console.error(\"‚ùå Error fetching real-time telemetry data:\", error);\n    return [];\n  }\n};\n\n// Cache management for latest telemetry entry\nlet latestEntryCache = {};\nlet lastLatestFetch = {};\n\n/**\r\n * Fetch the latest telemetry entry for a given deviceId (for dashboard indicators)\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Object>} - Latest telemetry entry\r\n */\nexport const getLatestTelemetryEntry = async deviceId => {\n  try {\n    // First check if device exists in CosmosDB\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/exists/${deviceId}`);\n    if (!response.ok) {\n      return null;\n    }\n    const exists = await response.json();\n    if (!exists) {\n      console.log(`No data found in CosmosDB for device: ${deviceId}`);\n      return null;\n    }\n\n    // If device exists, fetch latest entry\n    const dataResponse = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/latest/${deviceId}`);\n    if (!dataResponse.ok) {\n      return null;\n    }\n    const data = await dataResponse.json();\n    if (!data) {\n      return null;\n    }\n\n    // Cache the result\n    latestEntryCache[deviceId] = data;\n    lastLatestFetch[deviceId] = Date.now();\n    return data;\n  } catch (error) {\n    console.error(\"Error fetching latest telemetry:\", error);\n    return null;\n  }\n};\n\n/**\r\n * Clear all cache for a specific deviceId when switching devices\r\n * @param {string} deviceId - The ID of the device to clear cache for\r\n */\nexport const clearDeviceCache = deviceId => {\n  if (deviceId) {\n    // Clear specific device cache\n    delete historicalCache[deviceId];\n    delete lastHistoricalFetch[deviceId];\n    delete realtimeCache[deviceId];\n    delete lastRealtimeFetch[deviceId];\n    delete latestEntryCache[deviceId];\n    delete lastLatestFetch[deviceId];\n    console.log(`üßπ Cleared cache for device ${deviceId}`);\n  } else {\n    // Clear all cache\n    historicalCache = {};\n    lastHistoricalFetch = {};\n    realtimeCache = {};\n    lastRealtimeFetch = {};\n    latestEntryCache = {};\n    lastLatestFetch = {};\n    console.log('üßπ Cleared all device cache');\n  }\n};","map":{"version":3,"names":["axios","BASE_URL","process","env","REACT_APP_API_BASE_URL","defaults","timeout","retry","retryDelay","axiosInstance","create","interceptors","response","use","error","config","Promise","reject","retryCount","delay","console","log","resolve","setTimeout","historicalCache","lastHistoricalFetch","getTelemetryData","deviceId","now","Date","cacheTime","get","data","realtimeCache","lastRealtimeFetch","getRealtimeTelemetryData","latestEntryCache","lastLatestFetch","getLatestTelemetryEntry","fetch","REACT_APP_API_URL","ok","exists","json","dataResponse","clearDeviceCache"],"sources":["C:/Users/Garvisha/Desktop/New folder (2)/Front/oxygen-frontend/src/services/telemetryService.js"],"sourcesContent":["import axios from 'axios';\r\n\r\n// Use the correct base URL without the \"telemetry\" path\r\nconst BASE_URL = process.env.REACT_APP_API_BASE_URL || \"http://localhost:5000/api\";\r\n\r\n// Configure axios defaults for better error handling\r\naxios.defaults.timeout = 10000; // 10 second timeout\r\naxios.defaults.retry = 2;\r\naxios.defaults.retryDelay = 1000;\r\n\r\n// Create axios instance with retry logic\r\nconst axiosInstance = axios.create();\r\naxiosInstance.interceptors.response.use(null, async (error) => {\r\n  const { config } = error;\r\n  if (!config || !config.retry) {\r\n    return Promise.reject(error);\r\n  }\r\n  \r\n  config.retryCount = config.retryCount || 0;\r\n  if (config.retryCount >= config.retry) {\r\n    return Promise.reject(error);\r\n  }\r\n  \r\n  config.retryCount += 1;\r\n  const delay = config.retryDelay || 1000;\r\n  console.log(`Retrying request (${config.retryCount}/${config.retry})...`);\r\n  \r\n  return new Promise(resolve => setTimeout(() => resolve(axiosInstance(config)), delay));\r\n});\r\n\r\n// Cache management for historical telemetry data\r\nlet historicalCache = {};\r\nlet lastHistoricalFetch = {};\r\n\r\n/**\r\n * Fetch historical telemetry data (last 20 entries) for a given deviceId\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Array>} - Array of telemetry data points\r\n */\r\nexport const getTelemetryData = async (deviceId) => {\r\n  try {\r\n    // Implement cache control to prevent excessive API calls\r\n    const now = Date.now();\r\n    const cacheTime = 10000; // 10 seconds cache for historical data\r\n    \r\n    if (!historicalCache[deviceId] || !lastHistoricalFetch[deviceId] || \r\n        (now - lastHistoricalFetch[deviceId] > cacheTime)) {\r\n      console.log('üìä Fetching fresh historical telemetry data...');\r\n      const response = await axiosInstance.get(`${BASE_URL}/telemetry/${deviceId}`);\r\n      historicalCache[deviceId] = response.data || [];\r\n      lastHistoricalFetch[deviceId] = now;\r\n    } else {\r\n      console.log('üìä Using cached historical telemetry data...');\r\n    }\r\n    \r\n    return historicalCache[deviceId];\r\n  } catch (error) {\r\n    console.error(\"‚ùå Error fetching historical telemetry data:\", error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Cache management for real-time telemetry data\r\nlet realtimeCache = {};\r\nlet lastRealtimeFetch = {};\r\n\r\n/**\r\n * Fetch real-time telemetry data (last 10 minutes) for a given deviceId\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Array>} - Array of telemetry data points\r\n */\r\nexport const getRealtimeTelemetryData = async (deviceId) => {\r\n  try {\r\n    // Implement cache control with shorter lifetime for real-time data\r\n    const now = Date.now();\r\n    const cacheTime = 3000; // 3 seconds cache\r\n    \r\n    if (!realtimeCache[deviceId] || !lastRealtimeFetch[deviceId] || \r\n        (now - lastRealtimeFetch[deviceId] > cacheTime)) {\r\n      console.log('‚ö° Fetching fresh real-time telemetry data...');\r\n      const response = await axiosInstance.get(`${BASE_URL}/telemetry/realtime/${deviceId}`);\r\n      realtimeCache[deviceId] = response.data || [];\r\n      lastRealtimeFetch[deviceId] = now;\r\n    } else {\r\n      console.log('‚ö° Using cached real-time telemetry data...');\r\n    }\r\n    \r\n    return realtimeCache[deviceId];\r\n  } catch (error) {\r\n    console.error(\"‚ùå Error fetching real-time telemetry data:\", error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Cache management for latest telemetry entry\r\nlet latestEntryCache = {};\r\nlet lastLatestFetch = {};\r\n\r\n/**\r\n * Fetch the latest telemetry entry for a given deviceId (for dashboard indicators)\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Object>} - Latest telemetry entry\r\n */\r\nexport const getLatestTelemetryEntry = async (deviceId) => {\r\n  try {\r\n    // First check if device exists in CosmosDB\r\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/exists/${deviceId}`);\r\n    if (!response.ok) {\r\n      return null;\r\n    }\r\n    \r\n    const exists = await response.json();\r\n    if (!exists) {\r\n      console.log(`No data found in CosmosDB for device: ${deviceId}`);\r\n      return null;\r\n    }\r\n\r\n    // If device exists, fetch latest entry\r\n    const dataResponse = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/latest/${deviceId}`);\r\n    if (!dataResponse.ok) {\r\n      return null;\r\n    }\r\n    \r\n    const data = await dataResponse.json();\r\n    if (!data) {return null;\r\n    }\r\n\r\n    // Cache the result\r\n    latestEntryCache[deviceId] = data;\r\n    lastLatestFetch[deviceId] = Date.now();\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    console.error(\"Error fetching latest telemetry:\", error);\r\n    return null;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Clear all cache for a specific deviceId when switching devices\r\n * @param {string} deviceId - The ID of the device to clear cache for\r\n */\r\nexport const clearDeviceCache = (deviceId) => {\r\n  if (deviceId) {\r\n    // Clear specific device cache\r\n    delete historicalCache[deviceId];\r\n    delete lastHistoricalFetch[deviceId];\r\n    delete realtimeCache[deviceId];\r\n    delete lastRealtimeFetch[deviceId];\r\n    delete latestEntryCache[deviceId];\r\n    delete lastLatestFetch[deviceId];\r\n    console.log(`üßπ Cleared cache for device ${deviceId}`);\r\n  } else {\r\n    // Clear all cache\r\n    historicalCache = {};\r\n    lastHistoricalFetch = {};\r\n    realtimeCache = {};\r\n    lastRealtimeFetch = {};\r\n    latestEntryCache = {};\r\n    lastLatestFetch = {};\r\n    console.log('üßπ Cleared all device cache');\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}