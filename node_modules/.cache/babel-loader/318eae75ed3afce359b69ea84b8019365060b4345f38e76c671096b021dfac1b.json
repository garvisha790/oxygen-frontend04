{"ast":null,"code":"import axios from 'axios';\n\n// Use the correct base URL without the \"telemetry\" path\nconst BASE_URL = process.env.REACT_APP_API_BASE_URL || \"http://localhost:5000/api\";\n\n// Configure axios defaults for better error handling\naxios.defaults.timeout = 10000; // 10 second timeout\naxios.defaults.retry = 2;\naxios.defaults.retryDelay = 1000;\n\n// Create axios instance with retry logic\nconst axiosInstance = axios.create();\naxiosInstance.interceptors.response.use(null, async error => {\n  const {\n    config\n  } = error;\n  if (!config || !config.retry) {\n    return Promise.reject(error);\n  }\n  config.retryCount = config.retryCount || 0;\n  if (config.retryCount >= config.retry) {\n    return Promise.reject(error);\n  }\n  config.retryCount += 1;\n  const delay = config.retryDelay || 1000;\n  console.log(`Retrying request (${config.retryCount}/${config.retry})...`);\n  return new Promise(resolve => setTimeout(() => resolve(axiosInstance(config)), delay));\n});\n\n// Cache management for historical telemetry data\nlet historicalCache = {};\nlet lastHistoricalFetch = {};\n\n/**\r\n * Fetch historical telemetry data (last 20 entries) for a given deviceId\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Array>} - Array of telemetry data points\r\n */\nexport const getTelemetryData = async deviceId => {\n  try {\n    // Implement cache control to prevent excessive API calls\n    const now = Date.now();\n    if (historicalCache[deviceId] && lastHistoricalFetch[deviceId] && now - lastHistoricalFetch[deviceId] < 15000) {\n      return historicalCache[deviceId];\n    }\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/${deviceId}`);\n    if (!response.ok) {\n      return [];\n    }\n    const data = await response.json();\n    if (!data || !Array.isArray(data)) {\n      return [];\n    }\n\n    // Cache the result\n    historicalCache[deviceId] = data;\n    lastHistoricalFetch[deviceId] = now;\n    return data;\n  } catch (error) {\n    console.error(\"❌ Error fetching historical telemetry data:\", error);\n    return [];\n  }\n};\n\n// Cache management for real-time telemetry data\nlet realtimeCache = {};\nlet lastRealtimeFetch = {};\n\n/**\r\n * Fetch real-time telemetry data (last 10 minutes) for a given deviceId\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Array>} - Array of telemetry data points\r\n */\nexport const getRealtimeTelemetryData = async deviceId => {\n  try {\n    // Check cache first\n    const now = Date.now();\n    if (realtimeCache[deviceId] && lastRealtimeFetch[deviceId] && now - lastRealtimeFetch[deviceId] < 5000) {\n      return realtimeCache[deviceId];\n    }\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/realtime/${deviceId}`);\n    if (!response.ok) {\n      return [];\n    }\n    const data = await response.json();\n    if (!data || !Array.isArray(data)) {\n      return [];\n    }\n    realtimeCache[deviceId] = data;\n    lastRealtimeFetch[deviceId] = now;\n    return data;\n  } catch (error) {\n    console.error(\"Error fetching realtime data:\", error);\n    return [];\n  }\n};\n\n// Cache management for latest telemetry entry\nlet latestEntryCache = {};\nlet lastLatestFetch = {};\n\n/**\r\n * Fetch the latest telemetry entry for a given deviceId (for dashboard indicators)\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Object>} - Latest telemetry entry\r\n */\nexport const getLatestTelemetryEntry = async deviceId => {\n  try {\n    // First check if device exists in CosmosDB\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/exists/${deviceId}`);\n    if (!response.ok) {\n      return null;\n    }\n    const exists = await response.json();\n    if (!exists) {\n      console.log(`No data found in CosmosDB for device: ${deviceId}`);\n      return null;\n    }\n\n    // If device exists, fetch latest entry\n    const dataResponse = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/latest/${deviceId}`);\n    if (!dataResponse.ok) {\n      return null;\n    }\n    const data = await dataResponse.json();\n    if (!data) {\n      return null;\n    }\n\n    // Cache the result\n    latestEntryCache[deviceId] = data;\n    lastLatestFetch[deviceId] = Date.now();\n    return data;\n  } catch (error) {\n    console.error(\"Error fetching latest telemetry:\", error);\n    return null;\n  }\n};\nexport const verifyDeviceDataExists = async deviceId => {\n  try {\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/exists/${deviceId}`);\n    if (!response.ok) {\n      return false;\n    }\n    return await response.json();\n  } catch (error) {\n    console.error(\"Error verifying device data:\", error);\n    return false;\n  }\n};\n\n/**\r\n * Clear all cache for a specific deviceId when switching devices\r\n * @param {string} deviceId - The ID of the device to clear cache for\r\n */\nexport const clearDeviceCache = deviceId => {\n  if (deviceId) {\n    // Clear specific device cache\n    delete historicalCache[deviceId];\n    delete lastHistoricalFetch[deviceId];\n    delete realtimeCache[deviceId];\n    delete lastRealtimeFetch[deviceId];\n    delete latestEntryCache[deviceId];\n    delete lastLatestFetch[deviceId];\n    console.log(`🧹 Cleared cache for device ${deviceId}`);\n  } else {\n    // Clear all cache\n    historicalCache = {};\n    lastHistoricalFetch = {};\n    realtimeCache = {};\n    lastRealtimeFetch = {};\n    latestEntryCache = {};\n    lastLatestFetch = {};\n    console.log('🧹 Cleared all device cache');\n  }\n};","map":{"version":3,"names":["axios","BASE_URL","process","env","REACT_APP_API_BASE_URL","defaults","timeout","retry","retryDelay","axiosInstance","create","interceptors","response","use","error","config","Promise","reject","retryCount","delay","console","log","resolve","setTimeout","historicalCache","lastHistoricalFetch","getTelemetryData","deviceId","now","Date","fetch","REACT_APP_API_URL","ok","data","json","Array","isArray","realtimeCache","lastRealtimeFetch","getRealtimeTelemetryData","latestEntryCache","lastLatestFetch","getLatestTelemetryEntry","exists","dataResponse","verifyDeviceDataExists","clearDeviceCache"],"sources":["C:/Users/Garvisha/Desktop/New folder (2)/Front/oxygen-frontend/src/services/telemetryService.js"],"sourcesContent":["import axios from 'axios';\r\n\r\n// Use the correct base URL without the \"telemetry\" path\r\nconst BASE_URL = process.env.REACT_APP_API_BASE_URL || \"http://localhost:5000/api\";\r\n\r\n// Configure axios defaults for better error handling\r\naxios.defaults.timeout = 10000; // 10 second timeout\r\naxios.defaults.retry = 2;\r\naxios.defaults.retryDelay = 1000;\r\n\r\n// Create axios instance with retry logic\r\nconst axiosInstance = axios.create();\r\naxiosInstance.interceptors.response.use(null, async (error) => {\r\n  const { config } = error;\r\n  if (!config || !config.retry) {\r\n    return Promise.reject(error);\r\n  }\r\n  \r\n  config.retryCount = config.retryCount || 0;\r\n  if (config.retryCount >= config.retry) {\r\n    return Promise.reject(error);\r\n  }\r\n  \r\n  config.retryCount += 1;\r\n  const delay = config.retryDelay || 1000;\r\n  console.log(`Retrying request (${config.retryCount}/${config.retry})...`);\r\n  \r\n  return new Promise(resolve => setTimeout(() => resolve(axiosInstance(config)), delay));\r\n});\r\n\r\n// Cache management for historical telemetry data\r\nlet historicalCache = {};\r\nlet lastHistoricalFetch = {};\r\n\r\n/**\r\n * Fetch historical telemetry data (last 20 entries) for a given deviceId\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Array>} - Array of telemetry data points\r\n */\r\nexport const getTelemetryData = async (deviceId) => {\r\n  try {\r\n    // Implement cache control to prevent excessive API calls\r\n    const now = Date.now();\r\n    if (historicalCache[deviceId] && \r\n        lastHistoricalFetch[deviceId] && \r\n        (now - lastHistoricalFetch[deviceId] < 15000)) {\r\n      return historicalCache[deviceId];\r\n    }\r\n\r\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/${deviceId}`);\r\n    if (!response.ok) {\r\n      return [];\r\n    }\r\n\r\n    const data = await response.json();\r\n    if (!data || !Array.isArray(data)) {\r\n      return [];\r\n    }\r\n\r\n    // Cache the result\r\n    historicalCache[deviceId] = data;\r\n    lastHistoricalFetch[deviceId] = now;\r\n\r\n    return data;\r\n  } catch (error) {\r\n    console.error(\"❌ Error fetching historical telemetry data:\", error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Cache management for real-time telemetry data\r\nlet realtimeCache = {};\r\nlet lastRealtimeFetch = {};\r\n\r\n/**\r\n * Fetch real-time telemetry data (last 10 minutes) for a given deviceId\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Array>} - Array of telemetry data points\r\n */\r\nexport const getRealtimeTelemetryData = async (deviceId) => {\r\n  try {\r\n    // Check cache first\r\n    const now = Date.now();\r\n    if (realtimeCache[deviceId] && \r\n        lastRealtimeFetch[deviceId] && \r\n        (now - lastRealtimeFetch[deviceId] < 5000)) {\r\n      return realtimeCache[deviceId];\r\n    }\r\n\r\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/realtime/${deviceId}`);\r\n    if (!response.ok) {\r\n      return [];\r\n    }\r\n\r\n    const data = await response.json();\r\n    if (!data || !Array.isArray(data)) {\r\n      return [];\r\n    }\r\n\r\n    \r\n    realtimeCache[deviceId] = data;\r\n    lastRealtimeFetch[deviceId] = now;\r\n\r\n    return data;\r\n  } catch (error) {\r\n    console.error(\"Error fetching realtime data:\", error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Cache management for latest telemetry entry\r\nlet latestEntryCache = {};\r\nlet lastLatestFetch = {};\r\n\r\n/**\r\n * Fetch the latest telemetry entry for a given deviceId (for dashboard indicators)\r\n * @param {string} deviceId - The ID of the device to fetch data for\r\n * @returns {Promise<Object>} - Latest telemetry entry\r\n */\r\nexport const getLatestTelemetryEntry = async (deviceId) => {\r\n  try {\r\n    // First check if device exists in CosmosDB\r\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/exists/${deviceId}`);\r\n    if (!response.ok) {\r\n      return null;\r\n    }\r\n    \r\n    const exists = await response.json();\r\n    if (!exists) {\r\n      console.log(`No data found in CosmosDB for device: ${deviceId}`);\r\n      return null;\r\n    }\r\n\r\n    // If device exists, fetch latest entry\r\n    const dataResponse = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/latest/${deviceId}`);\r\n    if (!dataResponse.ok) {\r\n      return null;\r\n    }\r\n    \r\n    const data = await dataResponse.json();\r\n    if (!data) {return null;\r\n    }\r\n\r\n    // Cache the result\r\n    latestEntryCache[deviceId] = data;\r\n    lastLatestFetch[deviceId] = Date.now();\r\n    \r\n    return data;\r\n  } catch (error) {\r\n    console.error(\"Error fetching latest telemetry:\", error);\r\n    return null;\r\n  }\r\n};\r\nexport const verifyDeviceDataExists = async (deviceId) => {\r\n  try {\r\n    const response = await fetch(`${process.env.REACT_APP_API_URL}/telemetry/exists/${deviceId}`);\r\n    if (!response.ok) {\r\n      return false;\r\n    }\r\n    return await response.json();\r\n  } catch (error) {\r\n    console.error(\"Error verifying device data:\", error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Clear all cache for a specific deviceId when switching devices\r\n * @param {string} deviceId - The ID of the device to clear cache for\r\n */\r\nexport const clearDeviceCache = (deviceId) => {\r\n  if (deviceId) {\r\n    // Clear specific device cache\r\n    delete historicalCache[deviceId];\r\n    delete lastHistoricalFetch[deviceId];\r\n    delete realtimeCache[deviceId];\r\n    delete lastRealtimeFetch[deviceId];\r\n    delete latestEntryCache[deviceId];\r\n    delete lastLatestFetch[deviceId];\r\n    console.log(`🧹 Cleared cache for device ${deviceId}`);\r\n  } else {\r\n    // Clear all cache\r\n    historicalCache = {};\r\n    lastHistoricalFetch = {};\r\n    realtimeCache = {};\r\n    lastRealtimeFetch = {};\r\n    latestEntryCache = {};\r\n    lastLatestFetch = {};\r\n    console.log('🧹 Cleared all device cache');\r\n  }\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}